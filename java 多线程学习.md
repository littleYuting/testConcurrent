## 1. 基础知识
 
### 1.1 线程和进程
- 概念
    - 进程：程序的一次执行过程，系统运行程序的基本单位，具有独立性（地址空间）、动态性（生命周期）、并发性； 
    - 线程：轻量级进程，一个进程的执行过程中可产生多个线程，具有独立性、抢占性、并发性；
- 区别
    -  进程是系统进行资源分配和调度的基本单位，线程是其父进程的执行单位；
    -  同类的多个线程共享进程的堆、方法区、直接内存资源，单个线程独立拥有程序计数器、虚拟机栈和本地方法栈；
    ![](https://camo.githubusercontent.com/b997da2ae0e32fac704c8dc813973f3778316676/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d332f4a564d2545382542462539302545382541312538432545362539372542362545362539352542302545362538442541452545352538432542412545352539462539462e706e67)
    - 补充：
        - 堆和方法区：堆是进程中最大的一块内存，主要用于存放新创建的对象，方法区主要用于存放已被加载的类信息、常量、静态变量、即时编译器编译后的代码等数据；
        - 程序计数器的线程私有性：多线程下，保证线程切换后能恢复到正确的执行位置；
        - 虚拟机栈和本地方法栈的线程私有性：保证线程中的局部变量不被别的线程访问；
- 通信
    - 进程：信号量、共享存储（数据结构、存储空间）、消息队列（直接-电话，间接-信箱）、管道（匿名/命名，半双工，亲缘关系）、socket（不同系统间的进程通信）；
    - 线程：信号、信号量；
    - 临界区：一种公共资源或者说是共享数据，可被多个线程使用，但每次只能由一个线程，一旦被占用，其他线程要想使用就必须等待，在并行程序中，临界区资源是保护的对象；
- 进程调度
    - 先来先服务；
    - 【优先顺序】短作业优先、高响应比、优先级；
    - 时间片轮转；
    - 多级反馈队列（集大成）；
- 上下文切换
    - 概念：CPU从一个进程或线程切换到另一个进程或线程；
        - 上下文 是指某一时间点 CPU     寄存器和程序计数器的内容；
        - 寄存器 是 CPU 内部的数量较少但是速度很快的内存（与之对应的是 CPU 外部相对较慢的 RAM 主内存）；
        - 程序计数器是一个专用的寄存器，用于表明指令序列中 CPU 正在执行的位置，存的值为正在执行的指令的位置或者下一个将要被执行的指令的位置，具体依赖于特定的系统；
    - 步骤：
        - 挂起一个进程，将这个进程在 CPU 中的状态（上下文）存储于内存中的某处；
        - 恢复一个进程，在内存中检索下一个进程的上下文并将其在 CPU 的寄存器中恢复；
        - 跳转到程序计数器所指向的位置（即跳转到进程被中断时的代码行），以恢复该进程；
    - 类型：1）进程切换 2）线程切换 3）模式（用户/内核）切换 4）地址空间（虚拟/物理）切换
- 线程的生命周期

![](https://img-blog.csdn.net/20150309140927553)
![](https://camo.githubusercontent.com/e518e038e37c2d27abb394b00b438d347466c90c/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31392d312d32392f4a6176612b2545372542412542462545372541382538422545372538412542362545362538302538312545352538462539382545382542462538312e706e67)  
- 死锁
    - 概念：多进程/线程在运行过程中，因争夺资源而造成的一种僵局，互相等待；
    
    ![](https://camo.githubusercontent.com/3903a4dc24008be52f72bad23498808b5a743c35/68747470733a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f323031392d342f323031392d34254536254144254242254539253934253831312e706e67)
    - 原因：1）资源少，竞争大；2）进程推进顺序非法；3）资源分配不当；
    - 产生的必要条件：互斥；请求与保持；不可剥夺；循环等待；
    - 解决策略：预防（破坏死锁产生的必要条件）、避免/检测(银行家算法)、解除（暴力全杀or逐个击杀）；
    - 避免线程死锁：
        - 破坏请求与保持条件：一次性申请所有资源；
        - 破坏不剥夺条件：

- 并发（Concurrency）与并行（Parallelism）
    - “并行”概念是“并发”概念的子集，在多任务执行下，并发是针对某一时间段，并行是针对某一时刻；
    - 并发和并行都可以是很多个线程，若可同时被多个 cpu 执行则为并行，若只能被一个 cpu 轮流切换执行则为 并发；
- 同步与异步
    -  同步与异步，重点在于消息通知的方式（等待；轮训/被窗口通知）;
    -  同步：发送一个请求,等待返回,然后再发送下一个请求；
    -  异步:发送一个请求,不等待返回,随时可以再发送下一个请求；
    -  同步可避免死锁，异步可提高并发执行的效率；
- 阻塞与非阻塞
    - 阻塞与非阻塞，重点在于等消息时候的行为（挂起/非挂起）；
- 补充
    - 进程的同步、互斥与通信的区别
        - 进程的互斥与同步概念是在并发过程中存在的概念，目的是平衡竞争与协作的关系；
        - 为了解决进程间竞争关系（间接制约关系）而引入进程互斥，资源竞争会出现两个控制问题（死锁和饥饿）；
        - 为了解决进程间松散的协作关系(直接制约关系)而引入进程同步；
        - 为了解决进程间紧密的协作关系而引入进程通信；
        - 互斥是一种特殊的同步，进程同步是一种进程通信 
### 1.2 多线程
- 概念：多线程即多个线程同时运行（多核 CPU）或交替运行（单核 CPU）；
- 背景（为什么使用）
    - 必要：开发高并发系统时，充分利用多线程机制可极大提高系统整体的并发能力及性能，此外还提高了 CPU 的利用率；
    - 优势：线程间的切换和调度的成本远小于进程；
- 引入问题：内存泄漏、上下文切换、死锁、受限于硬件和软件的资源闲置问题；
- 创建和使用
    - 继承 Thread 类
    - 实现 Runnable 接口
    - 实现 Callable 接口
    - 使用 线程池（类型、优点、实现）
- 状态转换
    - 运行 <-> 阻塞
    
    > 调用 sleep 方法主动放弃所占用的处理器资源;  
      调用一个阻塞式 IO 方法;  
      试图获得一个被其他线程锁持有的同步监视器;  
      等待某个通知（notify）;  
      -> 调用 suspend 方法线程挂起，  <- 处于挂起状态的线程被调用 resume 方法;
    
    - 运行 <-> 就绪
    > 通常不受程序控制，而由系统线程的调度决定的；  
      调用 yield 方法可让线程从运行态转入就绪态；

    - dead
    > run 或 call 方法执行完成，程序结束;  
      线程抛出一个未捕获的 Exception 或者 Error;  
      直接调用该线程的 stop 方法来结束线程;
      
- 实例变量和线程安全
- synchronized
    - 保证同一时刻最多只有一个线程执行该段代码， 防止多线程干扰和内存一致性错误；
    - 若一个对象变量对多个线程可见，则对其所有读写均通过同步方法完成；
    - 分类
        - 对象锁：java 中每个对象均有一个 monitor 对象，即为 java 对象的锁，通常称为“内置锁”或“对象锁”，类对象可有多个，相应地对象锁也有多个，具有独立性，互不干扰；【synchronized(this|object){} 代码块和 synchronized 修饰非静态方法】
        - 类锁：每个类只有一个 class 对象，所以每个类只有一个类锁；【synchronized(类.class){} 代码块和 synchronized 修饰静态方法】
    - 使用
        - 两个线程访问一个对象的普通同步方法：需等待锁的释放；
        - 两个线程访问两个对象的普通同步方法：互相独立；
        - 两个线程访问静态同步方法：针对该类的所有对象锁一致，同步有效；
        - 两个线程分别访问普通同步方法和非同步方法：同步无效；
        - 两个线程分别访问一个对象的不同同步方法：锁一致，同步生效；
        - 两个线程分别访问静态同步和普通同步方法： 锁不同，同步不生效；
        - 抛出异常后，释放锁；
    - 补充
        - synchronized 关键字不能继承；
        - 在定义接口方法时不能使用 synchronized 关键字；
        - 构造方法不能使用 synchronized 关键字，但可以使用 synchronized 代码块来进行同步；
- 常用方法
- 补充：
    - run（）与 start（）
        - start() 方法被用来启动新创建的线程，而且 start() 内部调用了 run() 方法；
        - 如果调用 run 方法，系统会把线程对象当作普通的对象，会把线程的执行体当作普通方法来调用；
        - 在调用了 run 方法之后，该线程就不在处于新建状态，不能再调用该线程的start方法；
        - java 中只能对处于新建状态的线程使用 start 方法，否则将会引发 IllegalThreadStateException 异常；
        - 不要对一个已经死亡的线程调用 start 方法让它重新启动，死亡后的线程无法作为线程使用；
        - 设置后台线程时，setDaemon(true) 必须在 start 方法之前调用，否则会引发IllegalThreadStateException异常；
    - Java 中 Runnable 和 Callable 的不同
        - Runnable 和 Callable 都代表那些要在不同的线程中执行的任务，Runnable 从 JDK1.0 开始就有了，Callable 是在 JDK1.5 增加的；
        - 主要区别：Callable 的 call 方法可以返回值和抛出异常，且可返回装载有计算结果的 Future 对象，而 Runnable 的 run 方法无此功能；
    - sleep、wait、notify、join、yield 
    
    | item | 从属 | 是否释放锁 | 状态转变为 | 异常 |
    | :----: | :----: | :----: | :----: | :----: |
    | sleep | Thread 静态方法 | No | 阻塞 | InterruptedException |
    | wait | Object 公共方法 | Yes | 等待队列 | IllegalMonitorStateException+InterruptedException| 
    | notify/notifyAll | Object 公共方法 | -- | 同步队列 | IllegalMonitorStateException| 
    | join | Thread 公共方法 | No | 阻塞 | InterruptedException | 
    | yield | Thread 公共方法 | No | 可执行态 | 无| 
    ![](https://user-gold-cdn.xitu.io/2019/5/6/16a8b4111b0889be?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)

    - jvm 内存模型
    ![](https://user-gold-cdn.xitu.io/2018/12/29/167f8d722f215e49?imageView2/0/w/1280/h/960/format/webp/ignore-error/1)



参考文献

1. [Java中的进程与线程（总结篇）](https://www.cnblogs.com/WuXuanKun/p/6259965.html)  
2. [啃碎并发（三）：Java线程上下文切换](https://juejin.im/post/5b10e53b6fb9a01e5b10e9be)  
3. [并行与并发](https://www.zhihu.com/question/33515481)  
4. [Java中的进程与线程（总结篇）](https://www.cnblogs.com/WuXuanKun/p/6259965.html)
5. [线程篇2：[- sleep、wait、notify、join、yield -]](https://juejin.im/post/5ccfc04051882540ab167f86)  
6. [线程篇3：[-synchronized-]](https://juejin.im/post/5c27207ee51d4558873c693d)  
7. [java 之 syncronized 详解](https://juejin.im/post/594a24defe88c2006aa01f1c)
